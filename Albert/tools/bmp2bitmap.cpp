//
//  bmp2bitmap.cpp
//  Albert
//
//  Created by Matthias Melcher on 18.10.13.
//
//

#include "bmp2bitmap.h"

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>

#include "EasyBMP/EasyBMP.h"

//
// convert a .bmp file into a .s file that can be assembled by the gnu assembler into a NewtonOS bitmap
//
//  Command Line Parameters:
//  bmp2bitmap [--xbin] --label L003DAB18 [--top n] [--left n] --sym 0x003BBC78 img.bmp -o img.s
//


int gXBin = 0;
const char *gLabel = 0L;
int gTop = 0;
int gLeft = 0;
const char *gSym = 0L;
const char *gSrcPath = 0L;
const char *gDstPath = 0L;


int readArgs(int argc, char **argv)
{
  int i;
  for (i=1; i<argc; i++) {
    const char *arg = argv[i];
    if (strcmp(arg, "--label")==0) {
      if (i<argc-1) {
        gLabel = argv[++i];
      } else {
        printf("ERROR: argument missing for option --label\n");
        return 20;
      }
    } else if (strcmp(arg, "--xbin")==0) {
      gXBin = 1;
    } else if (strcmp(arg, "--top")==0) {
      if (i<argc-1) {
        gTop = atoi(argv[++i]);
      } else {
        printf("ERROR: argument missing for option --top\n");
        return 20;
      }
    } else if (strcmp(arg, "--left")==0) {
      if (i<argc-1) {
        gLeft = atoi(argv[++i]);
      } else {
        printf("ERROR: argument missing for option --left\n");
        return 20;
      }
    } else if (strcmp(arg, "--sym")==0) {
      if (i<argc-1) {
        gSym = argv[++i];
      } else {
        printf("ERROR: argument missing for option --sym\n");
        return 20;
      }
    } else if (strcmp(arg, "-o")==0) {
      if (i<argc-1) {
        gDstPath = argv[++i];
      } else {
        printf("ERROR: argument missing for option -o\n");
        return 20;
      }
    } else {
      if (arg[0]=='-') {
        printf("ERROR: unknown option %s\n", arg);
        return 20;
      } else if (gSrcPath) {
        printf("ERROR: multiple source files: \"%s\" and \"%s\"\n", gSrcPath, arg);
        return 20;
      } else {
        gSrcPath = argv[i];
      }
    }
  }
  if (gSrcPath==0L) {
    printf("ERROR: missing source file\n");
    return 20;
  }
  if (gDstPath==0L) {
    printf("ERROR: missing destination file\n");
    return 20;
  }
  if (gLabel==0L) {
    printf("ERROR: missing bitmap label (--label ...)\n");
    return 20;
  }
  if (gSym==0L) {
    printf("ERROR: missing symbol name (--sym ...)\n");
    return 20;
  }
  return 0;
}


int main(int argc, char **argv)
{
  int ret = readArgs(argc, argv);
  if (ret!=0)
    return ret;
  
  BMP bmp;
  ret = bmp.ReadFromFile(gSrcPath);
  if (ret==false) {
    printf("ERROR: can't read .bmp source file: \"%s\"\n", gSrcPath);
    return 20;
  }
  
  // get the BMP parameters
  int wdt = bmp.TellWidth();
  int hgt = bmp.TellHeight();
  int bytesPerRow = ((wdt+31)/32)*4;
  int binSize = bytesPerRow*hgt + 16;
//  printf("wdt %d hgt %d bytesPerRow %d binSize %d\n", wdt, hgt, bytesPerRow, binSize);
  
  
  
  FILE *f = fopen(gDstPath, "wb");
  if (!f) {
    printf("ERROR: can't write destination file: \"%s\", %s\n", gSrcPath, strerror(errno));
    return 20;
  }
  
  fprintf(f, "@\n@ This file was generated by bmp2bitmap\n@\n\n");
  // print the label line
  fprintf(f, "%s:\n", gLabel);
  // print the Newton Script Binary Object header
  if (gXBin) {
    fprintf(f, "\tNSObjXBin\t%d\n", binSize);
  } else {
    fprintf(f, "\tNSObjBin\t%d\n", binSize);
  }
  // pointer to symbol 'bits or 'mask
  fprintf(f, "\tNSPtr\t%s\n", gSym);
  // null word
  fprintf(f, "\t.int\t0x00000000\n");
  fprintf(f, "\t.short\t%d\t@ bytes per row\n", bytesPerRow);
  fprintf(f, "\t.short\t%d\t@ ...\n", gTop);
  fprintf(f, "\t.short\t%d\t@ top\n", gTop);
  fprintf(f, "\t.short\t%d\t@ left\n", gLeft);
  fprintf(f, "\t.short\t%d\t@ bottom\n", gTop+hgt);
  fprintf(f, "\t.short\t%d\t@ right\n", gLeft+wdt);
  
  int row, col, bb, i;
  for (row = 0; row<hgt; row++) {
    fprintf(f, "\t.byte\t");
    col = 0;
    for (bb = 0; bb<bytesPerRow; bb++) {
      unsigned char v = 0;
      for (i=0; i<8; i++) {
        if (col<wdt) {
          int m = col%8;
          RGBApixel px = bmp.GetPixel(col, row);
          int lum = px.Red + px.Green + px.Blue;
//          printf("%d %d %d\n", col, row, lum);
          if (lum<3*128) {
            v |= (0x80>>m);
          }
        }
        col++;
      }
      if (bb<bytesPerRow-1) {
        fprintf(f, "0x%02X, ", v);
      } else {
        fprintf(f, "0x%02X", v);
      }
    }
    fprintf(f, "\n");
  }
  
  fclose(f);
  
  return 0;
}

/** TODO: implement I/O of bitmap file
 L003DAD1C:
 NSObjBin        56                      @ B&W Bitmap
 NSPtr   SYMbits                         @ -> 0x003BBC78
 .int    0x00000000                      @
 .short  4                               @ (0x0004) bytes per row
 .short  178                             @ (0x00b2) ...
 .short  178                             @ (0x00b2) top
 .short  92                              @ (0x005c) left
 .short  188                             @ (0x00bc) bottom
 .short  105                             @ (0x0069) right
 .byte   0x07, 0x00, 0x00, 0x00          @ bitmap row
 .byte   0x07, 0x00, 0x00, 0x00          @ bitmap row
 .byte   0x0f, 0x80, 0x00, 0x00          @ bitmap row
 .byte   0x09, 0x80, 0x00, 0x00          @ bitmap row
 .byte   0x19, 0xc0, 0x00, 0x00          @ bitmap row
 .byte   0x10, 0xc0, 0x00, 0x00          @ bitmap row
 .byte   0x3f, 0xe0, 0x00, 0x00          @ bitmap row
 .byte   0x20, 0x60, 0x00, 0x00          @ bitmap row
 .byte   0x60, 0x70, 0x00, 0x00          @ bitmap row
 .byte   0xf0, 0xf8, 0x00, 0x00          @ bitmap row
 */

/*
 int TellBitDepth( void );
 int TellWidth( void );
 int TellHeight( void );
 int TellNumberOfColors( void );
 void SetDPI( int HorizontalDPI, int VerticalDPI );
 int TellVerticalDPI( void );
 int TellHorizontalDPI( void );
 
 BMP();
 BMP( BMP& Input );
 ~BMP();
 RGBApixel* operator()(int i,int j);
 
 RGBApixel GetPixel( int i, int j ) const;
 bool SetPixel( int i, int j, RGBApixel NewPixel );
 
 bool CreateStandardColorTable( void );
 
 bool SetSize( int NewWidth, int NewHeight );
 bool SetBitDepth( int NewDepth );
 bool WriteToFile( const char* FileName );
 bool ReadFromFile( const char* FileName );
 
 RGBApixel GetColor( int ColorNumber );
 bool SetColor( int ColorNumber, RGBApixel NewColor );
*/



