//
// DyneTK, the Dyne Toolkit
// Copyright (C) 2007 Matthias Melcher
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//

// generated by Fast Light User Interface Designer (fluid) version 1.0300

#include "Fldtk_Format_Slot_Editor.h"
#include <FL/Fl_Input.H>
#include <stdio.h>
#include <stdlib.h>

Fl_Menu_Item Fldtk_Format_Slot_Editor::menu_wFrame[] = {
 {"None", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"White", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"Light Gray", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"Gray", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"Dark Gray", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"Black", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"Custom", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"Matte", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Menu_Item Fldtk_Format_Slot_Editor::menu_wFill[] = {
 {"None", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"White", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"Light Gray", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"Gray", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"Dark Gray", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"Black", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"Custom", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Menu_Item Fldtk_Format_Slot_Editor::menu_wLines[] = {
 {"None", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"White", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"Light Gray", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"Gray", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"Dark Gray", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"Black", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"Custom", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 12, 0},
 {0,0,0,0,0,0,0,0,0}
};

Fldtk_Format_Slot_Editor::Fldtk_Format_Slot_Editor(Fl_Group *container, Dtk_Value_Slot *slot) : Fldtk_Value_Slot_Editor(container, slot), value_(0) {
  wValue_->hide();
position(0, 0);
begin();
Fl_Group *ct = buildUI_();
int dx = ct->x() + ct->w();
int dy = ct->y() + ct->h();
Fl_Box *res = new Fl_Box(x()+dx, y()+dy, w()-dx, h()-dy);
resizable(res);
end();
position(container->x(), container->y());
}

Fldtk_Format_Slot_Editor::~Fldtk_Format_Slot_Editor() {
}

void Fldtk_Format_Slot_Editor::value(double v) {
  value_ = (unsigned int)v;

char buf[32];

sprintf(buf, "%d", (value_>>8) & 15);
wPen->value(buf);

sprintf(buf, "%d", (value_>>24) & 15);
wRoundness->value(buf);

sprintf(buf, "%d", (value_>>16) & 3);
wInset->value(buf);

sprintf(buf, "%d", (value_>>18) & 3);
wShadow->value(buf);

switch (value_&15) {
  case 0:  wFill->value(0); break; // none
  case 1:  wFill->value(1); break; // white
  case 2:  wFill->value(2); break; // lt gray
  case 3:  wFill->value(3); break; // gray
  case 4:  wFill->value(4); break; // dk gray
  case 5:  wFill->value(5); break; // black
  case 14: wFill->value(6); break; // custom
}

switch (value_&0xf0) {
  case 0:   wFrame->value(0); break; // none
  case 16:  wFrame->value(1); break; // white
  case 32:  wFrame->value(2); break; // lt gray
  case 48:  wFrame->value(3); break; // gray
  case 64:  wFrame->value(4); break; // dk gray
  case 80:  wFrame->value(5); break; // black
  case 224: wFrame->value(6); break; // custom
  case 240: wFrame->value(7); break; // matte
}

switch (value_&0xf000) {
  case 0:     wLines->value(0); break; // none
  case 4096:  wLines->value(1); break; // none
  case 8192:  wLines->value(2); break; // white
  case 12288: wLines->value(3); break; // lt gray
  case 16384: wLines->value(4); break; // gray
  case 20480: wLines->value(5); break; // dk gray
  case 57344: wLines->value(6); break; // black
}
}

double Fldtk_Format_Slot_Editor::value() {
  unsigned int v = value_;

v &= 0xf0f00000;

v |= ( (atoi(wPen->value()) & 15 ) << 8 );
v |= ( (atoi(wRoundness->value()) & 15 ) << 24 );
v |= ( (atoi(wInset->value()) & 3 ) << 16 );
v |= ( (atoi(wShadow->value()) & 3 ) << 18 );

switch (wFill->value()) {
  case 0: v|= 0; break;
  case 1: v|= 1; break;
  case 2: v|= 2; break;
  case 3: v|= 3; break;
  case 4: v|= 4; break;
  case 5: v|= 5; break;
  case 6: v|= 14; break;
}

switch (wFrame->value()) {
  case 0: v|= 0; break;
  case 1: v|= 16; break;
  case 2: v|= 32; break;
  case 3: v|= 48; break;
  case 4: v|= 64; break;
  case 5: v|= 80; break;
  case 6: v|= 224; break;
  case 7: v|= 240; break;
}

switch (wLines->value()) {
  case 0: v|= 0; break;
  case 1: v|= 4096; break;
  case 2: v|= 8192; break;
  case 3: v|= 12288; break;
  case 4: v|= 16384; break;
  case 5: v|= 20480; break;
  case 6: v|= 57344; break;
}

return (double)v;
}

Fl_Group* Fldtk_Format_Slot_Editor::buildUI_() {
  Fl_Group* w;
  { Fl_Group* o = new Fl_Group(0, 0, 374, 126);
    w = o;
    o->box(FL_FLAT_BOX);
    o->color(FL_BACKGROUND_COLOR);
    o->selection_color(FL_BACKGROUND_COLOR);
    o->labeltype(FL_NO_LABEL);
    o->labelfont(0);
    o->labelsize(14);
    o->labelcolor(FL_FOREGROUND_COLOR);
    o->user_data((void*)(this));
    o->align(FL_ALIGN_TOP);
    o->when(FL_WHEN_RELEASE);
    { Fl_Box* o = new Fl_Box(415, 275, 10, 10);
      Fl_Group::current()->resizable(o);
    } // Fl_Box* o
    { wPen = new Fl_Input(85, 15, 50, 20, "Pen:");
      wPen->tooltip("Frame width in 0-15 pixels");
      wPen->type(2);
      wPen->labelsize(12);
      wPen->textsize(12);
    } // Fl_Input* wPen
    { wRoundness = new Fl_Input(85, 40, 50, 20, "Roundness:");
      wRoundness->tooltip("Corner radius of frame in 0-15 pixels");
      wRoundness->type(2);
      wRoundness->labelsize(12);
      wRoundness->textsize(12);
    } // Fl_Input* wRoundness
    { wInset = new Fl_Input(85, 65, 50, 20, "Inset:");
      wInset->tooltip("Whitespace between bounds and frame (0-3 pixels)");
      wInset->type(2);
      wInset->labelsize(12);
      wInset->textsize(12);
    } // Fl_Input* wInset
    { wShadow = new Fl_Input(85, 90, 50, 20, "Shadow:");
      wShadow->tooltip("Frame shadow (0-3 pixels)");
      wShadow->type(2);
      wShadow->labelsize(12);
      wShadow->textsize(12);
    } // Fl_Input* wShadow
    { wFrame = new Fl_Choice(200, 15, 150, 20, "Frame:");
      wFrame->down_box(FL_BORDER_BOX);
      wFrame->labelsize(12);
      wFrame->textsize(12);
      wFrame->menu(menu_wFrame);
    } // Fl_Choice* wFrame
    { wFill = new Fl_Choice(200, 40, 150, 20, "Fill:");
      wFill->down_box(FL_BORDER_BOX);
      wFill->labelsize(12);
      wFill->textsize(12);
      wFill->menu(menu_wFill);
    } // Fl_Choice* wFill
    { wLines = new Fl_Choice(200, 65, 150, 20, "Lines:");
      wLines->down_box(FL_BORDER_BOX);
      wLines->labelsize(12);
      wLines->textsize(12);
      wLines->menu(menu_wLines);
    } // Fl_Choice* wLines
    o->end();
  } // Fl_Group* o
  return w;
}

//
// DyneTK, the Dyne Toolkit
// Copyright (C) 2007 Matthias Melcher
//
